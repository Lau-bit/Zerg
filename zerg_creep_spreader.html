<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starcraft Creep Spreader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        body {
            background: #000;
            overflow: hidden;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Creep configuration
        const creepColor = { r: 89, g: 39, b: 104 };
        const creepHighlight = { r: 139, g: 58, b: 156 };
        const creepDark = { r: 45, g: 15, b: 55 };
        const veinColor = { r: 160, g: 80, b: 180 };
        
        // Grid-based creep simulation
        const cellSize = 8;
        let cols, rows;
        let creepGrid, creepAge;
        let startCorner = { x: 0, y: 0, dirX: 1, dirY: 1 };
        
        // Ripple system
        let ripples = [];
        
        // Pre-computed noise texture
        let noiseTexture1, noiseTexture2, noiseTexture3, veinTexture;
        
        // Saturation tracking
        let totalVisibleCells = 0;
        let isSaturated = false;
        let creepCount = 0;
        
        // Active edge cells for sparse iteration
        let activeEdges = new Set();
        
        function generateNoiseTexture(scale, seed) {
            const tex = new Float32Array(cols * rows);
            for (let i = 0; i < cols * rows; i++) {
                const x = i % cols;
                const y = Math.floor(i / cols);
                const n = Math.sin(x * scale * 12.9898 + y * scale * 78.233 + seed) * 43758.5453;
                tex[i] = n - Math.floor(n);
            }
            return tex;
        }
        
        function initGrid() {
            cols = Math.ceil(width / cellSize);
            rows = Math.ceil(height / cellSize);
            const size = cols * rows;
            
            // Visible cells equals total cells now (no buffer)
            totalVisibleCells = size;
            isSaturated = false;
            
            creepGrid = new Uint8Array(size);
            creepAge = new Float32Array(size);
            ripples = [];
            
            // Pre-compute noise textures at cell resolution
            noiseTexture1 = generateNoiseTexture(0.3, 0);
            noiseTexture2 = generateNoiseTexture(0.12, 100);
            noiseTexture3 = generateNoiseTexture(0.6, 200);
            veinTexture = generateNoiseTexture(0.2, 50);
            
            // Random corner selection
            const corner = Math.floor(Math.random() * 4);
            switch (corner) {
                case 0: // Bottom-left
                    startCorner = { x: 0, y: rows - 1, dirX: 1, dirY: -1 };
                    break;
                case 1: // Bottom-right
                    startCorner = { x: cols - 1, y: rows - 1, dirX: -1, dirY: -1 };
                    break;
                case 2: // Top-left
                    startCorner = { x: 0, y: 0, dirX: 1, dirY: 1 };
                    break;
                case 3: // Top-right
                    startCorner = { x: cols - 1, y: 0, dirX: -1, dirY: 1 };
                    break;
            }
            
            // Seed initial creep
            activeEdges = new Set();
            creepCount = 0;
            
            for (let dy = 0; dy < 3; dy++) {
                for (let dx = 0; dx < 3; dx++) {
                    const cx = startCorner.x + dx * startCorner.dirX;
                    const cy = startCorner.y + dy * startCorner.dirY;
                    if (cx >= 0 && cx < cols && cy >= 0 && cy < rows) {
                        const idx = cy * cols + cx;
                        creepGrid[idx] = 1;
                        creepAge[idx] = 1;
                        activeEdges.add(idx);
                        creepCount++;
                    }
                }
            }
            
            // Initial ripple
            ripples.push({
                x: startCorner.x * cellSize,
                y: startCorner.y * cellSize,
                radius: 0,
                maxRadius: 150,
                speed: 0.3,
                strength: 1
            });
        }
        
        // Spawn new ripples at creep edges
        function spawnRipple() {
            if (ripples.length >= 6) return;
            
            // Sample random cells instead of scanning all
            const samples = 50;
            const size = cols * rows;
            
            for (let i = 0; i < samples; i++) {
                const idx = Math.floor(Math.random() * size);
                if (creepGrid[idx] === 0) continue;
                
                const x = idx % cols;
                const y = Math.floor(idx / cols);
                
                // Quick edge check
                const up = y > 0 ? creepGrid[idx - cols] : 0;
                const down = y < rows - 1 ? creepGrid[idx + cols] : 0;
                const left = x > 0 ? creepGrid[idx - 1] : 0;
                const right = x < cols - 1 ? creepGrid[idx + 1] : 0;
                
                if (!up || !down || !left || !right) {
                    ripples.push({
                        x: x * cellSize,
                        y: y * cellSize,
                        radius: 0,
                        maxRadius: 80 + Math.random() * 120,
                        speed: 0.15 + Math.random() * 0.15,
                        strength: 0.6 + Math.random() * 0.4
                    });
                    return;
                }
            }
        }
        
        // Update ripples
        function updateRipples() {
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].radius += ripples[i].speed;
                if (ripples[i].radius > ripples[i].maxRadius) {
                    ripples.splice(i, 1);
                }
            }
        }
        
        // Spread creep organically using sparse edge iteration
        function spreadCreep() {
            if (isSaturated) return;
            
            const newEdges = new Set();
            const toRemove = [];
            
            for (const idx of activeEdges) {
                const x = idx % cols;
                const y = Math.floor(idx / cols);
                
                let hasEmptyNeighbor = false;
                
                // 8 neighbors
                const neighbors = [
                    { dx: -1, dy: -1 }, { dx: 0, dy: -1 }, { dx: 1, dy: -1 },
                    { dx: -1, dy: 0 },                      { dx: 1, dy: 0 },
                    { dx: -1, dy: 1 },  { dx: 0, dy: 1 },  { dx: 1, dy: 1 }
                ];
                
                for (const { dx, dy } of neighbors) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) continue;
                    
                    const nidx = ny * cols + nx;
                    
                    if (creepGrid[nidx] === 0) {
                        hasEmptyNeighbor = true;
                        
                        // Bias toward spreading away from start corner
                        const awayX = dx === startCorner.dirX;
                        const awayY = dy === startCorner.dirY;
                        
                        let spreadChance = 0.002;
                        if (awayX && awayY) spreadChance = 0.008;
                        else if (awayX || awayY) spreadChance = 0.005;
                        
                        // Add noise variation
                        const noiseVal = noiseTexture1[nidx];
                        if (noiseVal > 0.75) spreadChance += 0.006;
                        
                        if (Math.random() < spreadChance) {
                            creepGrid[nidx] = 1;
                            creepAge[nidx] = 1;
                            newEdges.add(nidx);
                            creepCount++;
                        }
                    }
                }
                
                // Age this cell
                creepAge[idx] = Math.min(100, creepAge[idx] + 0.2);
                
                // If surrounded, no longer an edge
                if (!hasEmptyNeighbor) {
                    toRemove.push(idx);
                }
            }
            
            // Update active edges
            for (const idx of toRemove) {
                activeEdges.delete(idx);
            }
            for (const idx of newEdges) {
                activeEdges.add(idx);
            }
            
            // Check saturation (98% coverage)
            if (creepCount >= totalVisibleCells * 0.98) {
                isSaturated = true;
            }
        }
        
        // Render creep with organic texture and ripples
        function render(time) {
            if (width <= 0 || height <= 0) return;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            // Pre-calculate ripple centers for this frame
            const rippleData = ripples.map(r => ({
                x: r.x,
                y: r.y,
                radius: r.radius,
                maxRadius: r.maxRadius,
                strength: r.strength,
                fade: 1 - (r.radius / r.maxRadius)
            }));
            
            // Global wave parameters
            const waveTime1 = time * 0.0003;
            const waveTime2 = time * 0.0004;
            const pulseTime = time * 0.0008;
            
            for (let cy = 0; cy < rows; cy++) {
                for (let cx = 0; cx < cols; cx++) {
                    const idx = cy * cols + cx;
                    if (creepGrid[idx] === 0) continue;
                    
                    const age = creepAge[idx];
                    const ageFactor = Math.min(1, age / 50);
                    
                    // Cell-level noise lookups
                    const n1 = noiseTexture1[idx];
                    const n2 = noiseTexture2[idx];
                    const n3 = noiseTexture3[idx];
                    const vn = veinTexture[idx];
                    
                    const isVein = vn > 0.75 && n3 > 0.4;
                    const bumpiness = n1 * 0.4 + n2 * 0.3 + n3 * 0.3;
                    
                    // Edge detection
                    const up = cy > 0 ? creepGrid[idx - cols] : 0;
                    const down = cy < rows - 1 ? creepGrid[idx + cols] : 0;
                    const left = cx > 0 ? creepGrid[idx - 1] : 0;
                    const right = cx < cols - 1 ? creepGrid[idx + 1] : 0;
                    const isEdge = !up || !down || !left || !right;
                    
                    // Cell center for ripple calculation
                    const cellCenterX = cx * cellSize + cellSize / 2;
                    const cellCenterY = cy * cellSize + cellSize / 2;
                    
                    // Calculate ripple effect once per cell
                    let rippleEffect = 0;
                    for (const r of rippleData) {
                        const dx = cellCenterX - r.x;
                        const dy = cellCenterY - r.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distFromRing = Math.abs(dist - r.radius);
                        
                        if (distFromRing < 25) {
                            const ringStrength = 1 - (distFromRing / 25);
                            const wave = Math.sin((dist - r.radius) * 0.3) * 0.5 + 0.5;
                            rippleEffect += ringStrength * r.fade * r.strength * wave;
                        }
                    }
                    
                    // Global undulation
                    const globalWave = Math.sin(cellCenterX * 0.015 + waveTime1) * 
                                      Math.sin(cellCenterY * 0.012 + waveTime2) * 0.075;
                    rippleEffect = Math.min(1, rippleEffect + globalWave);
                    
                    // Calculate cell color
                    let r, g, b;
                    
                    if (isEdge) {
                        const edgeGloss = (n3 > 0.6 ? 1.2 : 0.8) + rippleEffect * 0.4;
                        r = creepDark.r * edgeGloss;
                        g = creepDark.g * edgeGloss;
                        b = creepDark.b * edgeGloss;
                    } else if (isVein) {
                        const pulse = 0.8 + 0.2 * Math.sin(pulseTime + cellCenterX * 0.1);
                        const veinRipple = 1 + rippleEffect * 0.3;
                        r = veinColor.r * pulse * veinRipple;
                        g = veinColor.g * pulse * veinRipple;
                        b = veinColor.b * pulse * veinRipple;
                    } else {
                        const blend = bumpiness * ageFactor;
                        const rippleHighlight = 1 + rippleEffect * 0.5;
                        
                        r = (creepColor.r + (creepHighlight.r - creepColor.r) * blend) * rippleHighlight;
                        g = (creepColor.g + (creepHighlight.g - creepColor.g) * blend) * rippleHighlight;
                        b = (creepColor.b + (creepHighlight.b - creepColor.b) * blend) * rippleHighlight;
                        
                        if (n1 > 0.7) { r *= 1.15; g *= 1.15; b *= 1.15; }
                        if (n2 < 0.2) { r *= 0.7; g *= 0.7; b *= 0.7; }
                    }
                    
                    // Clamp colors
                    r = Math.min(255, Math.max(0, r)) | 0;
                    g = Math.min(255, Math.max(0, g)) | 0;
                    b = Math.min(255, Math.max(0, b)) | 0;
                    
                    // Fill cell pixels
                    const startX = cx * cellSize;
                    const startY = cy * cellSize;
                    const endX = Math.min(startX + cellSize, width);
                    const endY = Math.min(startY + cellSize, height);
                    
                    for (let py = startY; py < endY; py++) {
                        const rowOffset = py * width;
                        for (let px = startX; px < endX; px++) {
                            const pixelIdx = (rowOffset + px) << 2;
                            data[pixelIdx] = r;
                            data[pixelIdx + 1] = g;
                            data[pixelIdx + 2] = b;
                            data[pixelIdx + 3] = 255;
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Animation loop
        let lastSpread = 0;
        let lastRipple = 0;
        let lastRender = 0;
        const spreadInterval = 150;
        const rippleInterval = 2000;
        const normalRenderInterval = 0; // 60fps when not saturated
        const saturatedRenderInterval = 33; // ~30fps when saturated
        
        function animate(time) {
            // Only spread and spawn ripples if not saturated
            if (!isSaturated) {
                if (time - lastSpread > spreadInterval) {
                    spreadCreep();
                    lastSpread = time;
                }
                
                if (time - lastRipple > rippleInterval) {
                    spawnRipple();
                    lastRipple = time;
                }
            }
            
            // Always update existing ripples (let them finish)
            updateRipples();
            
            if (isSaturated && ripples.length === 0) {
                initGrid();
            }
            
            // Throttle rendering when saturated
            const renderInterval = isSaturated ? saturatedRenderInterval : normalRenderInterval;
            if (time - lastRender >= renderInterval) {
                render(time);
                lastRender = time;
            }
            
            requestAnimationFrame(animate);
        }
        
        initGrid();
        requestAnimationFrame(animate);
        
        window.addEventListener('resize', () => {
            resize();
            initGrid();
        });
    </script>
</body>
</html>
